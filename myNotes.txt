Creating React App (two options npx or npm): 
[1] npx create-react-app <project-name> 
(not installed globally so no worries about update package)

[2] npm creat-react-app -g
    create-react-app<project_name> 
(installed globally so needs update)

* note : remove <React.StrictMode> from index.js if React component render twice

    React : 
* is library not framework
* Focus on UI not Routing(1) or HTTP Requests
* Has a Rich EcoSystem(2)
* Has a component Based Architecture(3)
* is Declarative(4)
* will handle updating and rendering of the components
* will handle DOM updates



notes:
[1] Routing : is a technology for switching between different UI views, based on the changes of the current URL
[2] Rich EcoSystem : the interesting features and libraries that are available to use with React
[3] component Based Architecture : let you to break down the Application into small encapsulated parts then you can compose them and you has the ability also to reuse these components
[4] Declarative : Tell the React what you want and will build the actual UI
    ** Difference between Declarative programming and Imperative programming: 
    Declarative programming is a paradigm describing WHAT the program does, without explicitly specifying its control flow.
    Imperative programming is a paradigm describing HOW the program should do something by explicitly specifying each instruction (or statement) step by step.

    **Redux : Redux is a state management library (is a predictable state container for JavaScript apps ) that you can use with any JS library or framework like React, Angular, or Vue.
    https://www.freecodecamp.org/news/what-is-redux-store-actions-reducers-explained/amp/

Components : 
    * Root component (usually called APP) inside it there are 4 components :
        (1) Header component
        (2) Side Nav component
        (3) Main Content Component
        (4) Footer component

Types of Components :
    [A] Functional Component 
        a normal JS function returns HTML
        
        function welcome(props){
            return <h1>hello, {props.name}<h1>
        }
    
    [B] Class Component :
        a class Extending Component Class (from React library) and this class has render Method returns HTML
        
        class welcome extends React.component {
            render(){
                return <h1>hello, {this.props.name}<h1> 
            }
        }

JSX (JavaScript language syntax) : 
    * transiles to pure JS which is understood by Browser
    * Write XML-like code for elements and component
    * have a tag name , attributes and children
    * you can use React without JSX but with JSX code will be simpler
    * class => className -  for => htmlFor - onclick => onClick - tabindex => tabIndex

Props : 
    * is an object that's contains attributes and values which are passed in parent component ( inside App.js => like <Greet name="Ahmed"></Greet>) 
    * you can use props.children to get elements that added between <Greet></Greet> in parent component ( inside App.js )
    * props is immutable => you can not change it's value from Functional Component  or Class Component inside for Exp. Greet.js
    
Diffrence between State and Props : 
    Props : is Parameter passed to the component and immutable (can be accessed by props in Functional Component or this.props in Class component)
    State : is Variable and managed inside Component and mutable (can be accessed by useState Hook in Functional component or this.state in Class component)

setState :
    * a Method to make changes to state (When you change state directly without using setState you change it but not invoking Render Method so will change but will not shown on the page see exp. in counter.js)
    * has two Parameters (state Object , callBack Function)
    * 1st parameter (state object) can be replaced by function and this function has 2 parameters (prevState , props)
    * when you have to update state based on previous state value , pass in a functions as an argument to the setState method instead of state object
    * ASYNC Method (see exp. in counter.js) to solve this problem use 2nd parameter of setState Method 
    * 2nd Parameter used when you want to change state and invoke another function that use the new value of the state (see exp. in parentComponent.js)

prevState :
    Batching is when React groups multiple state updates into a single update. That is only one single re-render will eventually happen.
    so we use prevState (like new Variable created ) so you can increment it because state will update the value only one time

Shortcuts :
    * rce : class component
    * rcfe : function component
    * rpce : pure Component
    * rconst : construtor

EventBinding: 
    ** because Eventhandler Function is Async and excuted globaly so this will be window object ( in class will be undefined because of strict mode)
    we have 4 options to be sure that this will be class not undefined 

    [1] use bind keyword in render method  (bad performance)
    [2] use arrow function in render method  (bad performance)
    [3] use arrow function as class prop 
    [4] use bind keyword in construtor

Conditional render (exp. userGreeting.js):
    [1] if / else
    [2] Variable
    [3] ternary operator
    [4] short circuit operator

Keys of list :
    * has to be uniquex
    * to avoid a warning message on list (EXP. persons.js) add key property to each child
    * Key is not a prop (you can not access it see persons.js)
    * it is not recommended to use index as key because React link the item list to it's key
    so when add item at the begining you change the index of all items but when render the
    React will render the item (for Exp. item linked to key 0) to the old item linked to 0
    not the newly added item (see video 19 if you didn't understand)

Style in React :
    [1] CSS Stylesheet
    [2] inline styling (object has styles and should be camelCase see inline.js)
    [3] CSS Modules 
     * in regular CSS file import like this import "./appStyles.css" but from module will be like this import styles from "./appStyles.module.css"
     * using regular CSS file <h1 className='error'>Regular CSS</h1> but in module CSS <h1 className={styles.success}>Module CSS</h1>
     * CSS Module better than regular CSS because child component can use regular CSS File(imported to parent component) and this leads to conflict
     but in CSS Module you can not access it at child component because it's locally scoped (see inline.js)
    [4] CSS in JS libraries

LifeCycle Methods : 
    React component when created will call built-in Methods like constructor in Class component and those built-in methods you can override them : 

    [1] Mounting : when an instance of component is being created and inserted into the DOM
        (a)constructor  
        * constructor is perfect for : initializing state or binding (this) to event handler -- do not HTTP Requests inside constructor
        
        (b) static getDerivedStateFromProps(props , state)
        * used when the state of the component depends on changes in props over time.
        * is a static method that is called just before render() method in both mounting and updating phase in React. 
        It takes updated props and the current state as arguments. 
        We have to return an object(the updated state object) or null to indicate that nothing has changed.
                      
        (c) render 
            * The only required Method
            * Do not : Change the state or interact with DOM or make AJAX Calls

        (d) componentDidMount :
            * invoked only once and immediately after a component and all it's Children components has been rendered to the DOM
            * now you can DO : interact with DOM or AJAX calls

    [2] Updating : when a component is being re-render as a result of changes to either it's props or state
        (a) static getDerivedStateFromProps 
            * same like in Mounting

        (b) shouldComponentUpdate 
            * this method decide if the component should re-render or not 
            by default all components will re-render when they recieve a props or the state changes 
            but with shouldComponentUpdate method you can prevent this default behavior by returning false
        
        (c) render 
            * same like in Mounting

        (d) getSnapshotBeforeUpdate(prevProps , prevState)
            * is invoked right before the most recently rendered output is committed to e.g. the DOM. 
            It enables your component to capture some information from the DOM (e.g. scroll position) 
            before it is potentially changed. Any value returned by this lifecycle method 
            will be passed as a parameter to componentDidUpdate().
            * Exp. of using this Method is take the position of scroll of the user inside the website
            and return this information of position and this will be a parameter to componentDidUpdate() 
            so we can use this information to scroll agin the website to the same postion before updating
            * getSnapshotBeforeUpdate will be called before componentDidUpdate even the children 
        
        (e) componentDidUpdate(prevProps , prevState, snapshot)
            * Called only once after each re-render cycle
            * can use AJAX and use prevState with new State
    
    [3] Unmounting : when a component is being removed from the DOM
        (a) componentWillUnmount 
            * invoked immediatly before a component is unmounted or destroyed
            * can be used for cancelling any network requests , removing event handlers , cancelling any subscriptions and also invalidating timers

    [4] Error Handling : when there is an Error during rendering , a LifeCycle method , in a constructor in any child component 
        * Error Boundaries are React Component that catch JS Error in their child component tree 
        * A class component becomes an Error Boundary by definig either or both of getDerivedStateFromError and componentDidCatch (see ErrorBoundary.js) 
        * Error Boundary can not catch Error in event handler
        
        (a)static getDerivedStateFromError : is used to render a fallback UI after an error is thrown 
            
        (b)componentDidCatch(error , info) : is used to log the error information

Fragments : 
    * let you group list of children elements without adding extra nodes to DOM (see fragmentDemo.js and columns.js)
    * key attribute the only attribute can be added to React.Fragment
    * the shorthand of <React.Fragment></React.Fragment> is <></> but you can not add key attribute

Pure Component (works only with class component) : 
    Diffrence between Regular Component and Pure Component : 
    - shouldComponentUpdate implement : 
        * Regular Component does not implement shouldComponentUpdate method and always return true (that's why when changing state to same value will render see (parentComp.js))
        * Pure Component implement shouldComponentUpdate method with a shallow comparison of props and state ( that's why when changing state to same value will not render see (parentComp.js) )
        note : shallow comparison ( [a] primitive types : should be same value and same data type [b] Complex Types : both should reference to the same object like arrays or objects)
        note : if the state is an array do not use for exp. push method to array because you are mutating the same array with same reference so pure component will not render it's better to return new array with new reference

memo (because pure component does not work with functional component we use memo Component):
    * export default React.memo(MemoComp) / React.memo() called higher order component (later will discuss)

ref (reference can by added to DOM element or class Component): 
    * you can create a ref object by React.createRef() in constructor and use ref attribute on element to link this element to created ref
    and this element will be stored as property called current so you can get it by this.myRef.current and you can for exp. Focus on it by this.myRef.current.focus() 
    * or you can add ref attribute to class component inside parent component and access this component by this.inputComp.current see (focusInput.js)

callback ref : 
    * instead of using React.createRef() in the constructor:
    [1] we create an property called cbRef that is initially set to null. (see exp. refsDemo.js) 
    [2] create a method called setCbRef.
    [3] add ref attribute to the element and pass setCbRef method to it (now it's callback)
    [4] When the element mounts the callback ref (setCbRef method) is executed and the element will be an argument for this.setCbRef.
    note : The callback function passed to the ref attribute executes immediately upon the component mounting before componentDidMount fires so The referenced element is also guaranteed to be up to date before componentDidUpdate is executed.
    note : The stored element is directly accessible via this.cbRef (instead of stored as the .current attribute of the object created by React.createRef() or useRef()).

forward ref : 
    * a technique that forwards a ref through a component to one of its children
    * React.forwardRef(component) accept a component as a parameter and this component accept two parameter props and ref see (FRInput.js)

Protals : 
    * root in React : in index.js you will find that we are creating a root using ReactDOM.createRoot() method
    and add the div element that we want it as root by selecting it from index.html by using document.getElementById('root') the render with root and add APP component
    
    * But protals provide a way to render a children outside the root and steps are :
    [1] create an element in index.html and give it an ID (portal-root)
    [2] import ReactDOM  from 'react-dom' inside component (PortalDemo.js)
    [3] use ReactDOM.createPortal(JSX , element) accept 2 parameters 1st is JSX and 2nd is element that you created outside the root (portal-root)

    * use case of Portals is when you add style to all root DOM element and you need another element that does not inherit these styles

    * Note : portals is not inside root element but act as a child in React DOM so event bubbling still works if you click on portal element will buuble up to parents in React root ( https://codepen.io/gaearon/pen/jGBWpE)

Higher Order Component HOC : is a pattern that takes a component as an argument and returns a new component (see ClickCounter.js , HoverCounter.js and HOC.js) 
    * if you want to add for exp. same function to two components no need two write function to each component 
    you can create a function that accept these components as parameter (original component + function ) and return a new component  
    and you can access this function from props that you added inside render method of new component

    * if you want to pass a property to ClickCounter or HoverConuter from APP.js you have to write {...this.props} inside <OriginalComponent> in HOC.js
    because you already use ClickCounter and HoverConuter when you return UpdatedComponent(HoverCounter or ClickCounter) 
    so HoverConuter or ClickCounter inside APP.js not them they are updated version after using HOC

    * you can use 2nd paramter of HOC to use for any purpose you want for exp. (we added incrementNum so you can add different num for each HoverConuter or ClickCounter by returning export default UpdatedComponent(ClickCounter , 10) ) 
    
Render Props : 
    * render prop is a technique for sharing code between React Components using a prop whose value is a function
    * same concept of HOC you have function and you need to write it to ClickCounterTwo and HoverConuterTwo so you can use 3rd component
    like RenderProps.js and then you can add property(render property) to RenderProps component and this property can be a function and this function accepts
    parameters and return ClickCounterTwo or HoverConuterTwo component and add those paramters as property to them (now you shared them ) 
    and last step to call render property inside RenderProps.js

context : 
    * providing a way to pass data through the component tree without having to pass props down manually at every level
    (means if you have parent A and has child B and grandchild C without context you have to pass property username to A then B then C to access it from grandChild C)

    * Steps : 
        [1] create Context (see UserContext.js) : using React.createContext() Method then take from it 2 components Provider and Consumer
        [2] add Provider Component to APP Component and add property called value to it then inside Provider add ComponentA
        [3] add Consumer to GrandChild (ComponentC) and insid Consumer add function the parameter of this function is the property value that you added to Provider

    * you can add default value by adding it as parameter inside React.createContext() Method and if you didn't add Provider in APP.js 
    Consumer will search for Provider if not found will use default value

    * another steps using contextType (instead of adding consumer and then adding function and it's parameter will be the value property of Provider) : 
    we can export UserContext from UserContext.js and change ContextType of ComponentC to UserContext by (1) ComponentC.contextType = UserContext or (2) static contextType = UserContext
    then we can access value property by this.context 

    * but regular Context is better than typeContext because
    [1] typeContext works only with class component
    [2] with multiple contexts you can not use type context : 
        function content() {
            return (
                <themeContext.consumer>
                    {
                        theme => (
                            <userContext.consumer>
                                {
                                    user => (
                                        <profilepage user={user} theme={theme}></profilepage>
                                    )
                                }
                            </userContext.consumer>
                        )
                    }
                </themeContext.consumer>
            ) 
        }


HTTP : React does not do HTTP Request so we need to use another liberary with Reat (HTTP libraries like axios)

Side Effects : 
    * A React side-effect occurs when we use something that is outside the scope of React in our React components e.g. Web APIs like localStorage or HTTP-Requests or Document.title.
    * We usually manage React side effects inside the useEffect hook or LifeCycle Methods in Class Component like componentDidMount
    * when you add side effect inside React Component directly without useEffect Hook or LifeCycle Method every time the component renders 
    the side Effect will run and cause bad performance and if side effect has inside it changing state of component you will stuck in re-render infinite loop

Pure : 
    Most React components are pure functions, meaning they receive an input and produce a predictable output of JSX.
    it expects the same JSX for the same state/props regardless of how many times it renders

HOOKS : 
    * Allow you to use React features without having to write a class (EXP. state before should use class component with HOOKS no need for class component)
    * Do not work inside classes
    * Avoid the confusion of this keyword
    * Allow you to reuse stateful logic
    * Organize the logic inside a component into reusable isolated units
    * Only call Hooks at the Top Level (do not call hooks inside  loops, conditions or nested functions)
    * Only call Hooks from React Functions (call them from React Functional Component not regular JS Function)

useState Hook (lets you to add state to function component) : 
    is a function from React accepts an argumet ( initial value of state) and returns 
    array of the current value of state property and a method for updating state property
    * in class component state can be only object but with useState Hook state can be anything object , array , number ,.... 

The Update Method that's returned from useState : (two options to use it) (see HookCounterTwo.js) 
    [1] setState(new state value)
    [2] setState(function accepts prevState as an argument) this is safer incase of Batching

    * Difference between it and setState is setState merge the object but The Update Method does not (see ClassCounterThree.js and HookCounterThree.js)
     
    * for EXP. we have state object {firstName:"" , lastName: ""} when you use setState({firstName : "Soliman"}) 
    will not remove lastName property and state object will be like this {firstName:"Soliman" , lastName: ""}
    but with the Update Method when you setName({firstName : "Soliman"}) will remove lastName property
    and the object will be {firstName:"Soliman"} so you need to add it manually every time by using ...name

useEffect Hook (replacment for componentDidMount , componentDidUpdate and componentWillUnmount) : 
    * useEffect(function) will excute the function (which is passed as parameter) every time the component renders
    for EXP. instead of using componentDidMount , componentDidUpdate inside UseEffectOneClass.js we use useEffect() inside UseEffectOne.js

    ** Note : because useEffect hook excute function every render cycle will cause bad performance
    so you can add second parameter to the useEffect and this second paramter is an array (Dependancy array)and you can add 
    inside this array a value and the useEffect will excute the function only if that value changes (see UseEffectOne.js) 

    ** Note : to tell useEffect hook to excute the function only once (replacment componentDidMount in MouseClass.js) add second parameter empty array (see HookMouse.js)

    ** Note : the function inside useEffect can return another function(cleanup function) and this returned function will be excuted
    when the component unmounted (see HookMouse.js) (replacment componentWillUnmount in MouseClass.js)

useContext Hook : 
    * incase of nested consumers like in (ComponentB.js) you can use useContext(UserContext) and add UserContext (which is created by react.createContext() in App.js) as parameter
    and will return value of context Provider (UserContext.Provider or ChannelContext.Provider)
    so will be easier of nested consumers

useReducer : is used for state management (alternative to useState)
    * same concept of Array.prototype.reduce
        * Array.prototype.reduce(Reducer callBackFunction , initialValue) and callBackFunction(accumulator,currentValue) and return single value
        * useReducer(Reducer callBackFunction , initialState) and callBackFunction(currentState , action) return pair of values [newState, disptach]
    
    * Steps of useReducer in CounterOne.js : 
        [1] create Variables of initialState and reducer function(state , action)
        [2] use useReducer Hook which is return pair of values (count , disptach function)
        [3] use disptach function and it's parameter is the action argument of reducer function

    * state and action (parameters of reducer function) can be objects like in CounterTwo.js

    * you can use multiple useReducer like in CounterThree.js

    * you can combine useReducer and useContext Hooks like in ComponentD.js

    * useState is mostly used when types of states are number, boolean, and string. useReducer is used when types of states are objects and arrays.

react.memo : 
    * is a higher order component that's prevent the functional component to re-render if the props or stats did not change like in (Title.js or Count.js or Button.js)
    * Exp in (ParentComponent.js and Title.js , Count.js , Button.js) when using react.memo when you press button for age increment the button for salary increment will re-render
    because of two reasons : 
    [1] default behaviour of React when ParentComponent.js renders (because we changed the age state ) all it's Children will re-render (even if children props or state are the same) and to solve this problem will use react.memo
    [2] when the ParentComponent.js renders (because we changed the age state ) will create an new incrementSalary function so the props of salary button changed so the salary button component will re-render
    to solve this problem we will use useCallback Hook

useCallback Hook : 
    * a hook that will return a copy of callback function (cached Value) that only changes if one of the Dependancies has changed
    * should be used with react.memo
    * Exp in (ParentComponent.js and Title.js , Count.js , Button.js) useCallback Hook will return a copies of incrementSalary and incrementAge function 
    and those function will not created every time ParentComponent.js re-renders so props of salary button will not change when you click on age button (or vice versus)
    so salary button will not re-render

useMemo Hook : 
    * like useCallback Hook but will return a value of excuted function and will excute this function only if one of the Dependancies has changed
    * Exp in (MemoCounter.js) when MemoCounter Component renders isEven Function(contains while loop) will excute and take long time
    and MemoCounter component will re-render when you click on Count One or Two because you are changing state from incrementOne or incrementTwo Functions
    but by using useMemo Hook you solve this problem

useRef Hook : 
    * with useRef Hook you can access DOM Node directly from Functional Component.
    * same concept of using ref inside Class Component instead of using const inputRef = React.createRef() we will use useRef(null) and add inputRef to ref attribute inside DOM element
    and you can access the DOM element by inputRef.current see (FocusInput.js)
    ** Note : i tried const inputRef = React.createRef() and still works with functional Component

    * useRef Hook can be used as generic container which can hold a mutable value similar to instance property in class component see(HookTimer.js and ClassTimer.js)
    in HookTimer.js we used const interValRef = useRef() (like global variable because if we created this variable inisde useEffect we can not access it in onClick Event in Button) 
    so we created interValRef and we can access it's value by interValRef.current same concept of using interval (instance field) inside ClassTimer.js

custome Hook :
    * you can create your own custome Hook
    * custome Hook is a JS Function starts with "use"
    * custome Hook can call other Hooks if required
    * custome Hook can share Logic like HOCs(higher order Components) and Render Props
    * EXP1. useDocumentTitle is a custome Hook and we use it with DoctitleOne.js and DocTitleTwo.js
    * EXP2. useCounter is a custome Hook and we use it with CounterOnee.js and CounterTwoo.js
    * EXP3. useinput is a custome Hook and we use it with UserForm.js

Ways to cause Re-render : 
[1] useState setter function
[2] useReducer dispatch funcion
[3] if parent Component re-renders
[4] React Context

Render (initial Render ) steps in React : 
    [A] Render Phase : 
        React start from Root Component Tree and move downwards and at each element invoke createElement() Method to convert JSX to React Elements and store it

    [B] Commit phase : 
        Take the React Elements from Render Phase and apply them to the DOM using React DOM Package 


Re-render Steps in React : 
    [A] Render Phase : 
        When the component needs to update the component will be flagged and React will start from Root Component Tree and move downwards till finds flagged Component 
        then React will invoke createElement() Method to convert JSX to React Elements for each flagged component and then compare previous render to new render 
        then go to Commit phase . ( if no changes between previous render and new render will not go to commit phase and will not change DOM ) 
        
        The Component can flag itself for update by calling useState setter function or useReducer dispatch function 

    [B] Commit phase : 
        Take the changes from Re-Render Phase and apply them to the DOM using React DOM Package 

** if state value is primitive : 
useState setter function : if you update to the same value of current state will not re-render (except if not after initial Render cycle will re-render one more time then will not re-render again ) 
(if this is 1st re-render cycle and value is the same of initial Value the React will exit before comparing previous render to new Render
but if this is not 1st re-render and value is the same of current Value React will continue to comparing previous render to new Render and then Exit before commit phase)

useReducer dispatch function : after React 18 Update will re-render Even if the same Value

** if state value is array or object :
[1] if Object :
useState setter function : if you change the properties of the object React will not re-render
    because you are changing only properties but it's the same object with same reference 
    but if you change it to new object you changed the reference and then React will re-render (like in ObjectUseState.js )

[2] if Array :
useState setter function : same concept of object if you push values to the array you are not changing the array and still same Array and same reference
you have to change it to new Array with new reference (like in ArrayUseState.js)

useReducer dispatch function : after React 18 Update will re-render Even if the same reference but will not change UI on re-render (ObjectUseReducer.js & ArrayUseReducer.js)

Parent and Child Render behavior : 
    if Parent Re-render all Childs will re-render (default behavior of React)
    except in one case (if the value of state is the same and re-render not after initial Render cycle will re-render the parent only (only one time) ) see (parent.js & child.js and try count to 5 button)

    React render the top-level components and the other nested components within those components will not render they will be passed as props (this.props.children in class component or parameter of function component) 

    Difference between nested component and Child Component (<ChildOne/> inside ParentOne.js is Child Component but <OptimizedParentOne><ChildOne></ChildOne></OptimizedParentOne> in App.js is nested component )

    if you change the state of the component will re-render but will not re-render the child (child passed as parameter like in OptimizedParentOne.js) because React knows you can not change props 
    so for sure child component is the same and no need for re-render
    
    if you change state of grandParent Component (GrandParentOne.js) will re-render and will re-render parent(OptimizedParentOne.js) and also will re-render the grandChild (ChildOne.js) 
    because react now do not sure props of parent is the same or not because now you can change props so will re-render Child

to avoid unnecessary re-render of Child :
    [A] same Element reference : you can add child as nested component inside parent component in App.js then pass the Child as paramter (like in OptimizedParentOne.js).
    [B] React memo : is a higher order component that's prevent the functional component to re-render if the props or stats did not change (see ChildTwo.js and ParentTwo.js)
    
    ** Note : Difference between 2 options : 
    1st option works only if state of parent Changes but if props changes Child will re-render 
    2nd option Child will not re-render if props or state of parent changes


Incorrect Optimization : 

    [1] ChildThree.js (wrapped with memo) will re-render even if you press count button in ParentThree.js because props.children is always a new reference (if it's a HTML Element <strong></strong> same concept of reference in objects but if normal text same concept of primitive values will not be new reference so props will not change so ChildThree will no re-render) 
    when ParentThree.js re-render create new HTML with new reference) so you are changing the props of ChildThree every Time ParentThree.js re-render

    [2] same reason on [1] ChildFive.js will re-render event if you press count button in ParentFour.js because prop is always a new reference (when ParentFour.js re-render create new person object or new handle funcion with new reference) so change props of ChildFive.js so will re-render

    [3] ChildFour.js has now Date in JSX but you are wrapping it with memo so when you press on count buttion in parentThree.js ChildFour.js will not re-render (because of memo) so Date will not be updated in UI (Impure component)

to Solve Incorrect Optimization you can use useMemo & useCallback Hooks (like in ParentFour.js) :
    we used useMemo(() => person, []) so we returned person object only one time because of empty Dependancy array event if ParentFour re-render person object is the same and same reference
    we used useCallback(handleClick, []) so we returned callBackFunction only one time because of empty Dependancy array event if ParentFour re-render callBackFunction is the same and same reference

Re-render behavior with Context (see ContextChildren.js & ContextParent.js): 
    React render Context Provider and then check if the Provider take a new value ( value property ) if yes will re-render Context Consumer
    but default behavior of React when Parent re-render all Childs will re-render so we have 2 options : 
    [1] React.memo : we used MemoizedChildA = React.memo(ChildA) in ContextChildren.js then ChildC only will re-render when you press on count button in ContextParent.js
    [2] same Element reference : you can add child as nested component inside parent component in App.js then pass the Child as paramter (like in ContextParent.js). 

how to create react typescript : 
    npx create-react-app react-typescript-demo --template typescript

Optional Props : 
    you can add ? to make props optional like (messageCount?: number) in Greet.tsx
    and we destructured const { messageCount = 0 } = props and added default value 0 if it's not exist in props

when you add children to component in App.tsx file you have to write the children type in component
    * children is just text in <Heading> so we added children : string in Heading.tsx
    * children is another component <Oscar><Heading></Heading></Oscar> so we added children : React.ReactNode in Oscar.tsx
    
You can add Event handler function as prop but you have to write () => void as type in component file and if we want to use event parameter : 
    * Event (Click Event) >>> event: React.MouseEvent<HTMLButtonElement> in Button.jsx 
    * Event (Input Cahnge Event) >>> event: React.ChangeEvent<HTMLInputElement> in Input.jsx 

You can add css properties as a prop but you have to write styles: React.CSSProperties as type in component like in (Container.tsx)

Type inference means typescript is smart enough to know the type and you do not need to write it manually EXP : 
    * in LoggedIn.tsx => const [isLoggedIn, setIsLoggedIn] = useState(false) no need to write isLoggedIn : boolean 
    because typescript know it's boolean and this option called Type inference

if you want to add type to setState hook you can use <> like const [user, setUser] = useState<AuthUser | null>(null) in User.tsx
and when you try to use User.name typescript will automatically add ? like (User?.name) because you wrote <AuthUser | null> so maybe User is null (not exist)

Type assertion : 
    EXP : const [user, setUser] = useState<AuthUser>({} as AuthUser) in User.tsx 
    here you told typescript that even if user is empty object will be type AuthUser and no need to check (User?.name) if User exist or not 
    
    * and if you hover on setUser setter function will see React.setStateAction<AuthUser | null> because React infer that setter function will accept parameter
    of type AuthUser or null because you write type assertion useState<AuthUser>()

    * in Counter.tsx also if you hover on Disptach function will see React.dispatch<CounterAction>  because React infer that dispatch function will accept parameter
    of type CounterAction (dispatch's argument is useReducer's 2nd parameter = action ) and you wrote in useReducer that action:CounterAction 
    so React will infer the type

discriminated union :
    in Counter.tsx dispatch function accept parameter (action : CounterAction) but incase of reset will accept 
    action object with only type property no payload so typescript will give you an Error that action object should be two
    properties (type and payload) 
    [1] you can not use optional ? like (payload?:number) because incase of increment or decrement
    will give you an Error { count: state.count + action.payload } paylod can not be undefined
    [2] you can add payload = 0 on reset button but not the best solution
    [3] discriminated union : is the best solution you can create two different types (UpdateAction and ResetAction) and use 
    type CounterAction = UpdateAction | ResetAction now typescript will be smart enough to know which one will be used
    if you pass action parameter as an object with only one property(type) so will use ResetAction as type 
    if you pass action parameter as an object with two properties(type and payload) so will use UpdateAction as type

Context with typescript : 
    EXP1 : Box.tsx and theme.ts and ThemeContext.tsx
    EXP2 : User.tsx and UserContext.tsx

    **when creating context by (UserContext = createContext<UserContextType | null>(null)) in UserContext.tsx we are telling react 
    that the type context will be UserContextType or null so when we try to use userContext?.user?.name will put ?. after userContext
    because maybe userContext will be not exist
    so we used instead (const UserContext = createContext({} as UserContextType)) type assertion

non-null assertion operator : 
    operator tells the compiler to ignore the possibility of it being null.
    https://blog.logrocket.com/understanding-exclamation-mark-typescript/

useRef with typescript : 
    [1] ref for DOM Element (like in DomRef.tsx)
        * we can use null! (non-null assertion operator) instead of adding (?) in inputRef.current?.focus()
        * we added const inputRef = useRef<HTMLInputElement>(null!) because useRef() will be used in HTMLInputElement

    [2] generic container which can hold a mutable value similar to instance property (like in MutableRef.tsx)
        * here we added const interValRef = useRef<number | null>(null) number because we are assigning the id of interval to interValRef
        * we added if (interValRef.current) in stopTimer because const interValRef = useRef<number | null>(null) and 
        interValRef.current have possibility in window.clearInterval(interValRef.current) to be undefined and undefined not number or null
        so we added if (interValRef.current) in stopTimer or we can const interValRef = useRef<number | undefined>(undefined)
        

Difference between static field (or class variable or static variable) and instance field (instance variable) ?
    The static fields and methods can be accessed from the class itself 
    but Instances fields can be accessed from the instance object.

Difference between using state act as instance field (variable) or regular instance field (variable) ? 
    state act as instance variable serve different purposes. While calling setState with empty arguments will cause a render and will reflect the updated instance properties, 
    state can be used for many more features like comparing prevState and currentState in shouldComponentUpdate to decide whether you want to render or not, 
    or in lifecycle method like componentDidUpdate where you can take an action based on state change.
    state is a special instance property used by react to serve special purposes. 
    Also in setState, state updates are batched for performance reasons and state updates happen asynchronously unlike instance variable updates which happen synchronously. 
    
    A instance variable won't have these features.


class component with typescript (in counter.tsx) :
    we have to write the type of state and type of props :
    <type of props , type of state >
    export class Counter extends Component<CounterProps, CounterState> 
    * if you dont use props you can skip it by adding {} like <{} , type of state >
    * if you dont need state you can simply dont write it <CounterProps>

Component Prop with typescript (in Login.tsx , Private.tsx and Profile.tsx)
    * in Private.tsx we add Component: React.ComponentType<ProfileProps> React.ComponentType is type of react component and <ProfileProps> is type of props of this component
    * in Private.tsx we used Aliasing destructured variables (look there)

Generics with typescript and react (in List.tsx): 
    we should write <T extends > because it's not like Generic in function or Generic in classes (look at TS Elzero) you write <T> and then write the type when 
    you invoke the the function ( fnc<number>(5) ) or when you create instance ( new Obj<string>()) 
    but in react you are not invoking a function or creating instance you are adding the component to APP.tsx so you have to write <T extends theType> inside the component itself
    * <T extends String> 
    * <T extends Number> 
    * <T extends {}> means will accept anything like type any
    * <T extends { id: number }> means will accept object but this object must has property call id and it's value is number 

Restriction with typescript (in RandomNumber) :
    here we have 4 properties 
    [1] value : common with all possibilities
    [2] isPositive 
    [3] isNegative
    [4] isZero
    and we want to add 2 or 3 or 4 so we created 3 types and inside each type one is :boolean and the rest are ?: never
    then we add type RandomNumberProps = PositiveNumber | NegativeNumber | Zero and now typescript will be smart enough to know which one will be used 
    if you add isPositive typescript will use PositiveNumber 
    if you add isPositive and isNegative as properties inside APP.tsx typescript will throw an Error 

template literals with typescript (in Toast.tsx):
    * instead of writing 
    type ToastProps = {
        position : "left-center" | "left-top" | "left-bottom" | "center" | "center-top" | "center-bottom" | "right-center" | "right-top" | "right-bottom"
    }
    
    * we can write and react qill be smart enough to combine all possibilities
    type ToastProps = {
        position: `${HorizontalPosition}-${VerticalPosition}`
    }

    * but we have problem there is possibility center-center and we want it center only so we used Exclude 'center-center' and the add or center ( | "center")
    type ToastProps = {
        position: Exclude<`${HorizontalPosition}-${VerticalPosition}`, 'center-center'> | 'center'
    }

wrapping HTML Element (in Button.tsx and Input.tsx) : 
    * if you want to add types of all properties of an HTML Element you can use React.ComponentProps<'button'>
    * in Button.tsx we added custom property called variant so we have to write it's type so we added variant: 'primary' | 'secondary'
    * in Button.tsx we added type children : string but when you hover on children you will see string | React.ComponentProps
    and if you want to be only string you can use Omit keyword like Omit<React.ComponentProps<'button'>, 'children'> 
    and Omit means the use types (React.ComponentProps) of all properties except children
    * we can use ... to add rest of properties like ( {...rest})

Extracting a Components Prop Types (in CustomComponents.tsx) : 
    * you can use types from another Component (Greet.tsx) and use it inside CustomComponents.tsx by adding props: React.ComponentProps<typeof Greet>

Polymorphic Component (in Text.tsx) :
    * we added Omit<React.ComponentProps<E>, keyof TextOwnProps<E>> 
    because we do not want conflict between the types of own props and types of all default props of React.ComponentProps


------------------------------

- Redux : is a predictable state container for JS Apps.
- React-Redux : is a library that provides bindings to use React and Redux together in an application.

* React-Redux helps you to manage state and use it for different component because state container will be outside component tree
so no need to share state between parent and childs or grand childs
* useContext + useReducer can solve this problem also but React-Redux is more useful with big projects

Steps To create Redux project : 
[1] npm init --yes
[2] npm install redux

* JS doesn’t have access to change state in Redux state container directly it should tell mediator ( Reducer ) what changes to the state ( action ) and the mediator ( Reducer ) will inform the Store the required changes on the state 

* Reducer accepts two parameters ( previous state , action )  and return the new state to the application 


Action : 
* plain JS object 
* Must have type property ( string )

Action creator : is a function that return an action object


Redux Store : 
* allow access to state by getState() method
* Allow state to be updated by dispatch(action)
* Register listener via subscribe(listener) this is the link between store and JS application ( will execute listener function each time state changes) 
* You can unregister to the store by calling the function returned by subscribe(listener) 

To create Redux store 
[1] Const redux = require(‘redux’)
[2] const store = redux.createStore(reducer) 
[3] const unsubscribe = store.subscribe(listener)
[4] store.dispatch(action)
[5] unsubsrcibe() 


Combine reducers :
You can use one reducer for multiple actions but for large projects it’s better to use multiple reducers with multiple actions 

Steps : 
[1] const rootReducer =redux.combinereducers({cake: cakeReducer , iceCream : iceCreamducer })

Middleware : 
Provides a 3rd party extension point between dispatching an action and the moment it reaches the reducer 

* To install Logger ( npm install redux-logger ) ( will show you what happend , will show you each step at console)
Steps : 
[1] const reduxLogger = require(“redux-logger”)
[2] const logger = reduxLogger.createLogger()
[3] const store = redux.configureStore(rootReducer , reduxLogger.applyMiddleware(logger))

* To install Redux-Thunk ( npm install redux-thunk) (to allow action creator to return a function instead of action object and this function accept dispatch as parameter)
Steps : 
[1] const thunkMiddleware = require(“redux-thunk).default
[3] const store = redux.configureStore(rootReducer , redux.applyMiddleware(thunkMiddleware))
** note ( in userActions.js) : disptach(fetchUsers()) when this line get excuted then redux Middleware checks what it return , if it's object then excute as always 
if it returns a function then pass dispatch as an argument to that function.

* Steps to create react redux project: 
[1] npx create-react-app <project name>
[2] npm install redux react-redux

* The connect() function connects a React component to a Redux store.
    steps of connect: 
    [1] mapStateToProps allow access to state like getState() method 
    [2] mapDispatchToProps Allow state to be updated like dispatch(action)
    [3] Connect method from redux connects your React component to store and subscribe it to state changes

* The mapStateToProps and mapDispatchToProps deals with your Redux store’s state and dispatch, respectively. state and dispatch will be supplied to your mapStateToProps or mapDispatchToProps functions as the first argument.
    - mapStateToProps accept 2nd parameter (ownProps) so you can access props of component like in (ItemContainer.js) in this EXP. we can use ItemContainer for both cake and ice cream depends on props passed to this component
    - mapDispatchToProps accept 2nd parameter (ownProps) so you can access props of component like in (ItemContainer.js) in this EXP. we can use ItemContainer for both cake and ice cream depends on props passed to this component

* useSelector hook : is a function that accepts argument another function and the parameter of this function is state ( like mapStateToProps ) and useSelector hook returns what ever it’s argument function returns 
* UseDispatch hook : is a function that returns a reference to dispatch function 

* Steps of Middleware logger : 
    [1] npm i redux-logger
    [2] import { createStore , applyMiddleware} from 'redux'
    [3] const store = createStore(rootReducer , applyMiddleware(logger)) in rootReducer.js

* Steps of redux devtools extension : 
    [1] npm install --save -redux-devtools-extension
    [2] import { composeWithDevTools } from 'redux-devtools-extension'
    [3] const store = createStore(rootReducer ,composeWithDevTools( applyMiddleware(logger)))

* in NewCakeContainer.js weadded input html element to ask customer how many cakes he wants to buy 
then add the number as argument to action creator function then this number will be added as payload property in action object

* Steps of Async in react-redux in (userContainer.js): 
    [1] you need axios (for Async API calls) 
    [2] you need Thunk Middleware (to allow action creator to return a function instead of action object and this function accept dispatch as parameter)
    ** you can install both packages by ( npm install axios redux-thunk )
    [3] you need to use useEffect hook with empty array as Dependancy array
    
* conclusion how react-redux works : 
    [1] create component inside components folder ( mapStateToProps & mapDispatchToProps with connect like in CakeContainer) or (useSelector and UseDispatch Hooks)
    [2] create Actions , Types and Reducer inside redux folder  
    [3] create rootReducer.js if we want to combine more than one Reducer
    [4] create store.js to create store and add applyMiddleware if needed
    [5] create index.js if we want to import from ../redux folder without write specific location like import { buyCake, buyIceCream } from '../redux'
    ** incase of Async we need to add thunk Middleware in store.js and use useEffect Hook in component and make async calls in Actions.js

---------------------------------

*React router library : is fully featured client and server side routing library for React
    -Helps to create and navigate between different URLs to make up your web application
    -Provides unique URLs for different components
    In the app and makes the UI easily shareable with other users

*Steps to create React-router app : 
    [1] create react app : 
    npx create-react-app react-router-demo
    [2] add react router liberty: 
    yarn add react-router-dom@6
    or 
    npm install react-router-dom@6

*Steps for configuring route in react: 
    [1] import BrowserRouter inside index.js :
    Import { BrowserRouter } from ‘react-router-dom’ 
    [2] wrap app with BrowserRouter inside index.js
    [3] import Routes and Route inside App.js: 
    Import { Routes , Route } from ‘react-router-dom’ 
    [4] add two props to Route component ( path & element) 
    <Route path=‘about’ element={<Abou/t>}/>

*Steps for creating navbar : 
    [1] Create Navbar component and inside it import Link or NavLink component:
    Import { Link }  from ‘react-router-dom’ 
    Import { NavLink }  from ‘react-router-dom’ 
    [2] if you want to add styles add it inside index.css
    [3] add prop (to) Link component : 
    <Link to=‘/about’>About</Link> 

*Difference between Link and NavLink 
    When you press NavLink will add class (active) 
    To the clicked link and then you can is this in css styling ( inside index.css ) 
    or use style property in NavLink and inside this style prop add function which accepts isActive as parameter 
    and returns object contains the css styles

* The useNavigate hook returns a function (navigate function) that lets you navigate programmatically(navigates to the other routers using the push or replace methods)
    note : If using replace: true (as second parameter in navigate function), the navigation will replace the current entry in the history stack instead of adding a new one (by using push method).
    see OrderSummary.js and Home.js

* if the user try to write wrong route you can add <Route path='*' element={<NoMatch/>}/> in App.js to route the user to NoMatch page
 - note : path='*' means any path not exist in Routes

* nested Routes :  you can easily nest <Route><Route/></Route> see Products.js 
    - note : do not forget to import import { Link, Outlet } from 'react-router-dom' and use Outlet component inside Products.js
    An <Outlet> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered

* index Route : if you want to render child nested component automatically when parent render you can use 
    <Route index element={<FeaturedProducts/>}/> with index instead of path prop now when go to / products will 
    render product parent and FeaturedProducts child
    - note : Difference between adding <Route path="/users/admin" element /> and <Route path="user" element><Route path="admin" element/></Route>
    is nested child will render under parent so on webpage you will see both parent and child 
    but incase path="/users/admin" you will see only admin page without users page
    
* Dynamic Route : ":" colon is used to make the route dynamic and the parameters can be accessed using the name "userId" (by using useParam hook )as provided in the route path after colon.
    see Users.js , 

* useParam Hook see(UserDetails.js): 
    [1] import { useParams } from 'react-router-dom'
    [2] useParams() returns object contains dynamic Route ( ":" colon )
    [3] you can destructuring it const { userId } = useParams()

* useSearchParams Hook see(Users.js) : 
    [1] import { useSearchParams } from 'react-router-dom'
    [2] const [searchParams, setSearchParams] = useSearchParams() ( same concept of useState Hook)

* Relative Links see(Products.js) : 
    <Link to='featured'>Featured</Link>
    here if we write to='/featured' the link will be from Root not from the current URL

* Lazy Loading see(App.js) : 
    <Suspense> component that lets you “wait” for some code to load 
    and you can add component (fallback='component') or just string (fallback='Loading...') that will be shown to webpage while we’re waiting
    [1] import React from 'react'
    [2] const LazyAbout = React.lazy(() => import('./components/About'))
    [3] <React.Suspense fallback='Loading...'><LazyAbout /></React.Suspense>

* Authentication and protected Routes
    https://youtu.be/X8eAbu1RWZ4
    -note : A <Navigate> element changes the current location when it is rendered. It's a component wrapper around useNavigate, and accepts all the same arguments as props.
    Having a component-based version of the useNavigate hook makes it easier to use this feature in a React.Component subclass where hooks are not able to be used.

---------------------------


*Steps to create React-table app : 
    [1] create react app : 
    npx create-react-app react-table-demo
    [2] add react table liberty: 
    yarn add react-table
    or 
    npm install react-table

* Steps to create basic table (BasicTable.js , MOCK_DATA.json , columns.js , table.css) : 
    [1] Get the date you want to display 
        (to create MOC-data (JSON File) use https://mockaroo.com/)
    [2] Define the Columns for you table ( in columns.js)
        - Header : your custom name of column Header
        - Footer : your custom name of column Footer
        - Accessor : the name of column inside JSON file
        * You can choose what columns you want to extract from JSON file you should not extract all columns from JSON file
        * useMemo hook to ensure data doesn’t recreated every render
    [3] Use the data and columns defined to create a table instance 
        -using useTable Hook from react-table (in BasicTable.js )
    [4] Define a basic table structure using plain HTML
        - in BasicTable.js
    [5] Use the table instance created in step 3 to bring life to the HTML defined in step 4 
        - in BasicTable.js
    [6] Include the desired CSS
        - in table.css

* Header Groups : instead of accessor : "" use column : [] in (columns.js)

* Sorting (in SortingTable.js): 
    useSortBy hook : you can add it as 2nd argument to useTable hook so will add sorting feature to the table
    now you can pass column.getSortByToggleProps() as an argument to ...column.getHeaderProps() in <th> inside <thead> so will add props related to sorting features on this column 

* Formatting : 
    - react table needs a proper date format ( ISO ) to support sorting features so JSON file data format is ISO
    but we can change UI Format to user after filter

    -To format data in column you can : 
        Add cell after header , footer and accessor in column.js 
        - Cell is function accepts alot of arguments but we needs only value 
        - Cell function returns format(new Date(value) , dd/mm/yyyy) 
        - 1st argument we used new Date because in JSON file value is just a string and we want convert it to date
        - 2nd argument of format function is the new format that we want the value changes to it 

    * note : 
        To install date package :
        yarn add date-fns
        Or 
        Npm install date-fns


 * Filtering (in FilteringTable.js) : 
    [1] Global filter : for all columns
        - useGlobalFilter hook : you can add it as 2nd argument to useTable hook so you can destructuring state and setGlobalFilter from useTable hook  then we can destructuring globalFilter from state
        - Add GlobalFilter component from GlobalFilter.js and add globalFilter and setGlobalFilter as props to this component 
    [2] Column filter : for specific column
        - useFilters hook : you can add it as 2nd argument to useTable hook 
        - Add ColumnFilter component (Filter: ColumnFilter) to every column in columns.js
        - column.render('Filter') in FilteringTable.js

    * note : if you do not need to add (Filter: ColumnFilter) to every column you can use defaultColumn (dont forget to add it as an argument to useTable hook)will add it automatically to each column
    * useAsyncDebounce : incase of big data for better performance recommended to use useAsyncDebounce hook 
    will filter every 1 sec not every time to type a letter 
        - import { useAsyncDebounce } from 'react-table'
        - const [value, setValue] = useState(filter)
        - const onChange = useAsyncDebounce(value => {setFilter(value || undefined)}, 1000)


 * Pagination (in PaginationTable.js) :
    - usePagination : you can add it as 2nd argument to useTable hook so you can destructuring (
    page ,
    nextPage,
    previousPage,
    canPreviousPage,(Boolean value true if not first page and can go back false if first page)  
    canNextPage,(Boolean value true if not last page and can go forward false if last page)
    pageOptions, (can get number of pages by pageOptions.length)
    state, (then we can destructuring pageIndex, pageSize from state)
    gotoPage,
    pageCount,
    setPageSize,
    )

    * note : if we want to start page at specific page add this (initialState: { pageIndex: 2 }) as an argument to useTable Hook
    * note : if we want to change page size we can use setPageSize function and destructuring pageSize from state

* Row Selection :
    - useRowSelect hook : you can add it as 2nd argument to useTable hook so you can destructure selectedFlatRows

* Column Order (in ColumnOrder.js) :
    - useColumnOrder hook : you can add it as 2nd argument to useTable hook so you can destructure setColumnOrder method from the useTable Hook
    then you can use setColumnOrder method which accepts array of column (accessor) and will change the order of table like order of accessors in this array

* Column Hiding (in ColumnHiding.js) : 
    - you can destructure (allColumns,getToggleHideAllColumnsProps) from useTable Hook directly no need to add another hook as 2nd argument
    - add getToggleHideAllColumnsProps if you want to hide all columns
    - add column.getToggleHiddenProps() if you want to hide one column only

* Sticky Columns  (in StickyColumns.js):
    - install package ( npm i react-table-sticky )
    - install package ( npm i styled-components )
    - useBlockLayout, useSticky hooks : you can add them as 2nd argument to useTable hook
    - in columns.js add sticky: 'left' to the desired column

-----------------------

* Storybook : is an isolated development environment and playground for UI Component ( create component independently ) 

 
* Install storybook package: 
- npx create-react-app react-storybook-v6
- npx sb init

* In main.js in .storybook folder there is () that means will search for any file called .stories.js and will search inside this file for default export and named exports and run them so we don’t add button component to App.js


* You can change story name like in ( Input.stories.js) Small.storyName = “Small Input”

* If you want to sort stories alphabetically you can copy options object from stories docs and paste it in preview.js 

* You can merge stories in one story ( story within story ) like in ( Subscription.stories.js ) added Primary from input.stories and Large from Button.stories to Subsriptions.Stories.js

* Args in(Button.stories.js): 
    - Args can be used to dynamically change props, slots, styles, inputs, etc. It allows Storybook and its addons to live edit components
    - When an arg’s value changes, the component re-renders, allowing you to interact with components in Storybook’s UI via addons that affect args.
    - The args object can be defined at the story story level or component level ( in export default and will be applied to all stories components but if story component has same property will override it ) or global level

* Decorator : 
    for EXP. to center button without decorator:
        [1] Create center.css and center.js
        [2] wrap every story button with <Center></Center>
    with decorator :
        write this (decorators: [story => <Center>{story()}</Center>],) to default export in Button.stories.js 
        and will wrap every story with <Center></Center> 

        * note : every entry inside array of decorators is a function whichs accept story as an argument
        * note : addDecorator no longer supported in V6 or V7

    to add global decorators : 
        decorators: [Story => (<Center><Story/></Center>)] in preview.js

* Theming : 
    - install Chakra UI Packages : npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion
    - same concept of decorators you wrap stories with theme (like wrap stories with <Center></Center> in Button.stories.js)
    to add global decorators : 
        decorators: [(Story) => (
                <ThemeProvider theme={theme}>
                    <CSSReset />
                    <Box m='4'>
                    <Story />
                    </Box>
                </ThemeProvider>
                )] 
                in preview.js

    * note : <Box m="4"> to add margin to the button    
             <CSSReset/> to add CSS from Chakra UI Packages

* Addon : 
    * Controls : ( by default in V7 ) be sure that you are using arg (const Template =  args => <Button {...args} /> in ChakraButton.stories.js) without args controls addon will not work
    * Actions : ( by default in V7 ) Log user action and work really well with args mechanism for EXP. onClick Action we added ({ onClick: { action: 'clicked' } } to argTypes in in ChakraButton.stories.js)
    * Docs : ( by default in V7 ) in V6 was a tab in toolbar but in V7 is a seperate file and if you need to add it be sure to write (docs: {autodocs: true}) in main.js 
    * viewport :(by default in V7) will add icons to toolbar 
        - if you want to add more options of viewport like more mobile phones steps :
            [1] import {INITIAL_VIEWPORTS} from '@storybook/addon-viewport'in preview.js
            [2] viewport: {viewports: INITIAL_VIEWPORTS,} in parameters in preview.js
    * Console : not supported yet in V7
    * Knobs : supported in V7 
        steps : 
            [1] install Knobs package ( npm install @storybook/addon-knobs --dev )
            [2] add "@storybook/addon-knobs" in main.js
            [3] add import { withKnobs } from '@storybook/addon-knobs'; and add withKnobs to Decorators
            [4] add import { text, boolean } from '@storybook/addon-knobs' in story
        - note : but when disable button you can not see stop sign like in V5 but still diabled no problem 
    * A11y : Test component compliance with web accessibility standards
        steps : 
        [1] install a11 package (npm i -D @storybook/addon-a11y)
        [2] add "@storybook/addon-a11y" in main.js

* Environment Variable : 
    [1] STORYBOOK_ in package.json file in scripts ("storybook": "STORYBOOK_THEME=dark storybook dev -p 6006",)
    [2] access it by (process.env.STORYBOOK_THEME)
    * note in window add (set STORYBOOK_THEME=dark &&) in mac without (set and &&)

--------------------------

* Formik : is a small library helps you to 
- Handle form data
- Validation 
- Visual feedback with error messages 
- Form submission 

* install formik package : 
npm i formik

* useFormik hook (in OldYoutubeFormik.js): is a function thats return a formik object has proberties and methods like (values , initialValues , handleChange ,...) 
and accepts argument object and this object can has  properties like  :
[1] intialValues : and value of this property is an object and properties of this object should be the same name attribute in input element 
[2] onSubmit : and value of this property is a function which accept form state object (formik.values )  as an argument and this function automatically executes once you press on Submit Button
[3] validate : and value of this property is a function which accept form state object (formik.values )  as an argument and return error object which is change errors proberty inside formik object

* useFormik hook will return an object which is has handleChange method (formik.handleChange() or formik.handleSubmit() ) and value (formik.values) .  Like setState and state in useState Hook 

- note : formik.handleSubmit() will invoke onSubmit function inside the argument object of useFormik hook and will stop refresh the page automatically when press submit button 

- note : onBlur={formik.handleBlur} will add proberty (name of property is the name of element and the value is boolean true if you blur inside input element) to formik.touched 
    then we can use formik.touched.name or email or channel to check if you clicked inside this input element or not
    so you will validate only this input element not all input elements

* Yup liberary : liberary to validate form 
    to install : npm i Yup

* instead of adding [ onChange={formik.handleChange} onBlur={formik.handleBlur} value={formik.values.name}] to each input element in Form 
we can add {...formik.getFieldProps("name")} (argument is the value of name attribute) and will add onChange , onBlur and value attribute automatically

* Formik component is a substitute for useFormik hook and steps are (in YoutubeFrom.js) : 
[1] import Formik instead of useFormik
[2] wrap the entire form with Formik component <Formik></Formik> 
[3] add the arguments we added before to useFormik hook () as attributes to Formik Component 

* Form component instead of form element (in YoutubeForm.js) : 
[1] import {Form} form “formik”
[2] add Form component instead of <form></form> element
[3] remove onSubmit event prop because Form component will add it automatically 

* Field component instead of input element (in YoutubeForm.js) : 
[1] import {Field} form “formik”
[2] add Field component instead of <input></input> element
[3] remove {...formik.getFieldProps("email")} because Field component will add it automatically 


* ErrorMessage component instead of {formik.errors.email && formik.touched.email? (<div className='error'>{formik.errors.email}</div>) : null} (in YoutubeForm.js) : 
[1] import {ErrorMessage} form “formik”
[2] add ErrorMessage component and will render only when the input element is visited and there is an Error
[3] add name property (same like name proberty in Field Component which is also the same name attribute in input element in OldYoutubeForm.js )


* Field component render as input element but if you want Field component to render as text area you should add (as=‘textarea’ or component =‘textarea) prop to it 

* Render Props :
    In YoutubeForm.js you can easily add field component and will render as input element but we have another option 
    to add function as a children to this Field component and this function returns input element ( but you have to link to to formik by add {...field} or {...form.getFieldProps("address")})
    This function accepts props and this props object has (field , form , meta ) properties : 
        [1] field prop : values of this prop is object of ( name , onBlur , onChange and value ) to help you to manage state 
        [2] form prop : values of this prop is the same formik object that return from useFormik hook 
        [3] gives you information if field visited or not , error exists or not and value ( used to render error messages ) 

* ErrorMessage render text not html element to force ErrorMessage to render html element instead of just rendering a text : 
    [1] add  component=‘div’ prop 
    Or 
    [2] add component={TextError} * TextError is a component ( TextError.js ) 
    Or 
    [3] Render props : Children of ErrorMessage will be a function and parameter of this function is the error message text : 
    <ErrorMessage name='email'>{error => <div className='error'>{error}</div>}</ErrorMessage>

* Nested Object: 
    steps :
        [1] add nested object to initialValue 
        [2] in Field Component add name='social.facebook' instead of name='facebook'

* Arrays (): 
    steps :
        [1] add the array to initialValue (phoneNumbers: ['', '']) so will be only 2 fields if you want to add or remove field dynamically use FieldArray component
        [2] in Field Components add name="phoneNumbers[0]" and name="phoneNumbers[1]"

* FieldArray (will give you dynamic array - you can add or remove to phNumber array ): 
    steps : 
        [1] import FieldArray from 'formik'
        [2] add the array to initialValue (phNumbers: [""])
        [3] in FieldArray add name="phNumber"
        [4] use Render Props pattern ( children is a function and inside this function will accept fieldArrayProps as parameter and 
            destructure form , remove , push from fieldArrayProps then will destructure values from form then will destructure phNumbers array from values ) 
        [5] map on phNumbers array to render Field Component and you can add more element to phNumbers array using push method (that will render more Field component) 
            and you can remove element from phNumbers array (that will remove Field Component)

* Field Component vs FastField (address vs address2 fields in YoutubeForm.js): 
    * Any changes to form ( like typing inside Field input component will render all Filed Components in the form to re-render ) 
    FastField Component will solve this problem will re-render FastField component only when you type in it not when you type in any other Field


* When Validation runs in formik : 
    [1] change event ( when you type inside field input component)  you can stop validation on change event by adding validateOnChange={false} as a prop to Formik 

    [2] blur event ( when you click inside field input component and then click outside ) you can stop validation on blur event by adding validateOnBlur={false} as a prop to Formik 

    [3] submit the form (if the validation not ok on submit handler will not executed ) 

* Field level Validation (for specific Field) : 
    - before in OldYoutubeForm.js we used two ways for validation [1] validate [2] validateSchema Yup liberary
    and both of validations ways are top level whichs means can validate the selected Field from validate function or validateSchema object
    - steps for Field level Validation : 
        [1] define validate function (like validate function in top level validation ... the function (validateComments) accept value of comments Field as parameter )
        [2] add validate property to comments Field and assign validateComments function to this prop 

* Manually triger validation : 
    [1] you needs to use render props pattern form entire From : children of Formik Component is a function whichs accept 
    formik object as parameter ( with formik object we can control manual triger of validation) values of this parameter is the same formik object that return from useFormik hook and also same value of form object in render props in address field
    [2] add onClick event and the function is formik.validateField() ... empty paramter means will validate all field or you can write which field you want to validate 
        (but also will not give you the Error because we have 2 conditions to give you error 1st condition is didn't write anything in Field and 2nd condition is touching the Field (click inside and then click outside))
    [3] add onClick event and the function is formik.setTouched() ... here you should write which fields you want to set as touched fields empty parameter not allowed
        (now will give you the Error)

* How to Stop Submit : [1] when form is invalid [2] during submitting process
    [1] when form is invalid :
        (a) formik.isValid : readonly prop true if error object is empty 
        (b) add disabled={!formik.isValid} to submit button so the button will be disabled when form is invalid
        - note : if you want to disable the submit button once page mount you can add validateOnMount prop to Formik Field
        - formik.dirty : boolean value prop true if you change a value of any field (not blur should type inisde the field and change the value)

    [2] during submitting process (means when you press on submit we want to disable submit button till submition process to server finish then we can submit again to prevent double submittion at the same time)
        (a) formik.isSubmitting : boolean value true if submission is in process
        (b) disabled={formik.isSubmitting} to disable the button during submission process
        - note formik does not know when the server respond so you have to return formik.isSubmitting back to false by (submitProps.setSubmitting(false)) (submitProps is a 2nd argument in onSubmit Method)


* Load saved Data as initial values of the From : 
    [1] import {useState} from 'react' 
    [2] destructure const [formValues, setFormValues] = useState(null) then initialValues={formValues || initialValues}
    [3] create savedData object (that will replace initial values of the Form)
    [4] add enableReinitialize prop to Formik Component to enables the form to change initial values
    [5] add button load data and onClick event and inside this event setFormValues(savedValues) (to simulate API Call)

* Reset Data in the Form : 
    [1] add reset button to the form
    [2] reset the form after submiting by (submitProps.resetForm() in onSubmit method)

* formik videos end at video 30 ... from video 31 we are building an Example and use what we learned

* ChakraInput library in(chakraInput.js): 
    -Form control component has isInvalid prop if false will not render FormErrorMessage component 
    -Benefits of using ChakraInput Library is no need to write css or create TextError.js and pass it as component prop inside ErrorMessage 

-----------------------------
Benefits of React styled component : 
* Automatic critical CSS ( inject css styling only to the components will render 
* No class name ( if you have two css files maybe will one will override the other if you use same class name like styles.css and app.css ) 
* Easier deletion on css style ( because each css style is linked to specific component so when you delete a component will delete automatically it’s css style ) 
* Dynamic CSS styling (means now css style can be different according to props of component )
* Painless maintenance 
* Automatic vendor prefixing ( no need to write different vendor prefixes to be compatible with different browsers this library will handle this ) 

npm install styled-components

Dynamic CSS : when you use a function inside Es6 template string this function will accept component prop as an argument ( like in Button.styles.js ) 

Extending styles : you can reuse styles of one component and add extra styles to it ( like in Button.styles.js …. Const FancyButton = styled(styledButton) this means FancyButton will take styles of styledButton and then you can add extra style like linear-gradient)

Pseudo classes : 
Add (&:hover ) ( like in Button.styles.js ) 

Passed props to be element attributes :
When you add type=‘submit’ to StyledButton will be passed automatically to button element  ( like in Button.styles.js ) 

Adding attributes: you can add attribute to component by using attrs constructor and this constructor accepts an object as argument or accept a function which is returns an object and this function accepts props as an argument ( like in Button.styles.js ) 

Animation : 
Import { keyframes } from ‘styled-component’
and you can assign this keyframes to variable and then use this variable to animation inside component ( like AnimatedLogo component in Button.styles.js )

Theme : 
[1] Import { ThemeProvider } from ‘styled-component’
[2] wrap all jsx in App.js with ThemeProvider
[3] add theme prop 
Now you can access theme prop from any component under ThemeProvider

createGlobalStyle : There are times where you want to style your React application globally and not each component individually. 
For this, we can make use of the createGlobalStyle API and the component created by createGlobalStyle ( GlobalStyle ) is under ThemeProvider so has access also to theme 



