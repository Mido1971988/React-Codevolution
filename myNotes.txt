    React : 
* is library not framework
* Focus on UI not Routing(1) or HTTP Requests
* Has a Rich EcoSystem(2)
* Has a component Based Architecture(3)
* is Declarative(4)
* will handle updating and rendering of the components
* will handle DOM updates


notes:
[1] Routing : is a technology for switching between different UI views,Â based on the changes of the current URL
[2] Rich EcoSystem : the interesting features and libraries that are available to use with React
[3] component Based Architecture : let you to break down the Application into small encapsulated parts then you can compose them and you has the ability also to reuse these components
[4] Declarative : Tell the React what you want and will build the actual UI
    ** Difference between Declarative programming and Imperative programming: 
    Declarative programming is a paradigm describing WHAT the program does, without explicitly specifying its control flow.
    Imperative programming is a paradigm describing HOW the program should do something by explicitly specifying each instruction (or statement) step by step.

    **Redux : Redux is a state management library (is a predictable state container for JavaScript apps ) that you can use with any JS library or framework like React, Angular, or Vue.
    https://www.freecodecamp.org/news/what-is-redux-store-actions-reducers-explained/amp/

Components : 
    * Root component (usually called APP) inside it there are 4 components :
        (1) Header component
        (2) Side Nav component
        (3) Main Content Component
        (4) Footer component

Types of Components :
    [A] Functional Component 
        a normal JS function returns HTML
        
        function welcome(props){
            return <h1>hello, {props.name}<h1>
        }
    
    [B] Class Component :
        a class Extending Component Class (from React library) and this class has render Method returns HTML
        
        class welcome extends React.component {
            render(){
                return <h1>hello, {this.props.name}<h1> 
            }
        }

JSX (JavaScript language syntax) : 
    * transiles to pure JS which is understood by Browser
    * Write XML-like code for elements and component
    * have a tag name , attributes and children
    * you can use React without JSX but with JSX code will be simpler
    * class => className -  for => htmlFor - onclick => onClick - tabindex => tabIndex

Props : 
    * is an object that's contains attributes and values which are passed in parent component ( inside App.js => like <Greet name="Ahmed"></Greet>) 
    * you can use props.children to get elements that added between <Greet></Greet> in parent component ( inside App.js )
    * props is immutable => you can not change it's value from Functional Component  or Class Component inside for Exp. Greet.js
    
Diffrence between State and Props : 
    Props : is Parameter passed to the component and immutable (can be accessed by props in Functional Component or this.props in Class component)
    State : is Variable and managed inside Component and mutable (can be accessed by useState Hook in Functional component or this.state in Class component)

setState :
    * a Method to make changes to state (When you change state directly without using setState you change it but not invoking Render Method so will change but will not shown on the page see exp. in counter.js)
    * has two Parameters (state Object , callBack Function)
    * 1st parameter (state object) can be replaced by function and this function has 2 parameters (prevState , props)
    * when you have to update state based on previous state value , pass in a functions as an argument to the setState method instead of state object
    * ASYNC Method (see exp. in counter.js) to solve this problem use 2nd parameter of setState Method 
    * 2nd Parameter used when you want to change state and invoke another function that use the new value of the state (see exp. in parentComponent.js)

prevState :
    Batching is when React groups multiple state updates into a single update. That is only one single re-render will eventually happen.
    so we use prevState (like new Variable created ) so you can increment it because state will update the value only one time

Shortcuts :
    * rce : class component
    * rcfe : function component
    * rconst : construtor

EventBinding: 
    ** because Eventhandler Function is Async and excuted globaly so this will be window object ( in class will be undefined because of strict mode)
    we have 4 options to be sure that this will be class not undefined 

    [1] use bind keyword in render method  (bad performance)
    [2] use arrow function in render method  (bad performance)
    [3] use arrow function as class prop 
    [4] use bind keyword in construtor

Conditional render (exp. userGreeting.js):
    [1] if / else
    [2] Variable
    [3] ternary operator
    [4] short circuit operator

Keys of list :
    * has to be uniquex
    * to avoid a warning message on list (EXP. persons.js) add key property to each child
    * Key is not a prop (you can not access it see persons.js)
    * it is not recommended to use index as key because React link the item list to it's key
    so when add item at the begining you change the index of all items but when render the
    React will render the item (for Exp. item linked to key 0) to the old item linked to 0
    not the newly added item (see video 19 if you didn't understand)

Style in React :
    [1] CSS Stylesheet
    [2] inline styling (object has styles and should be camelCase see inline.js)
    [3] CSS Modules 
     * in regular CSS file import like this import "./appStyles.css" but from module will be like this import styles from "./appStyles.module.css"
     * using regular CSS file <h1 className='error'>Regular CSS</h1> but in module CSS <h1 className={styles.success}>Module CSS</h1>
     * CSS Module better than regular CSS because child component can use regular CSS File(imported to parent component) and this leads to conflict
     but in CSS Module you can not access it at child component because it's locally scoped (see inline.js)
    [4] CSS in JS libraries

LifeCycle Methods : 
    [1] Mounting : when an instance of component is being created and inserted into the DOM
        (a)constructor (b) static getDerivedStateFromProps (c) render (d) componentDidMount 
    
    [2] Updating : when a component is being re-render as a result of changes to either it's props or state
        (a) static getDerivedStateFromProps (b) shouldComponentUpdate (c) render (d) getSnapshotBeforeUpdate (e) componentDidUpdate
    
    [3] Unmounting : when a component is being removed from the DOM
        (a) componentWillUnmount

    [4] Error Handling : when there is an Error during rendering , a LifeCycle method , in a constructor in any child component
        (a)static getDerivedStateFromError (b)componentDidCatch

